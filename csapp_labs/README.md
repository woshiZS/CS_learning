### Machine Level Representation

> 算是随便记录的一点笔记，开始想记这个笔记的时候已经看到第三章了

* 完成condition branch那里比较有意思，一种更有效率的做法是conditional move instruction，就是条件转移，这样相较于conditional jump来说更有效率。(指令流水线的原因，condition jump会可能发生预测错误，但是是conditional data move指令执行不依赖于数据，conditional move实现的具体细节会在后面章节里面讲到)
* 参数寄存器：rdi, rsi, rdx, rcx，先后顺序用该是反过来的，因为参数压栈是从右往左
* lea指令不会设置condition code.
* loop算是由普通指令和conditional jump指令一起实现的
* 中间循环算是跳过很多内容没有记笔记了，主要还是循环那一块的内容，包括循环转化为汇编的几种格式。熟悉一下即可，帮助不是很大。
* 之后讲了一下，数组在汇编中的表示形式，包括iso c99引入动态维度的静态数组。
* 另外就是结构体，其实也是指针做一个偏移运算，重点还是内存对齐(padding)，另外讲了一点union的好处--节省内存。
* union的另外一个作用就是在获取相同的bit representation，比如在将double转化为unsigned long的时候，如果使用的是强制转型，转化之后的字节表示可能会有非常大的不同，但是使用union的话，可以将double储存到union的一个field，然后再访问另外一个field即可。
* 另外讲了两个无符号整形存储在一个union的时候要注意编址方式，注意一点，大端是按照正常人的顺序来存储的，小端存储与人的直觉相反。
* 对于内置类型来说，大小为K字节的object的地址必须是K的整数倍，所有的数据对齐都是基于这个原则，为什么int, char, int中间的char要补三个字节，原因就是不补充的话，我们是没法做到让前后两个int地址同时是四的倍数。
* 缓冲区溢出以及解决方案
* address space stack randomization, 攻击者的应对手段可以不断暴力枚举，nop sled来破解
* 第三种方式就是限制memory 权限，刚开始read和execute权限用的一个bit flag，之后amd为execute引入了独立的flag，后来英特尔也进行了效仿。
* 主要来说，应对缓冲区溢出攻击比较常见的就是这三种方法

### Program Optimization

(写到这里的时候，公司那边已经写了一点了，估计要等后期merge才能整合到一块了).

* C编译器无法事先确定代码中是否有内存应用，所以每次进行内存的读写时，他是不会对内存读写做临时变量的优化的。
  * 要了解底层处理器设计，可以选修ECE 741这门课程
* 除法对于任何机器而言都是一项比较昂贵的操作
* 之后有讲到数据依赖导致指令无法并行执行，此时引入了循环展开的操作
* 除了考虑数据依赖之外，吞吐量也会导致并行效率（一般由于硬件造成），比如说机器有两个乘法单元，但是加载单元只有一个，所以实际上没法充分利用多个乘法单元的优势。课程视频中也有提到一次加载两个数据，然后就可以同时使用两个乘法单元的例子（具体细节还是要去看书）。